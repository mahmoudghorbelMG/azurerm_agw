---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "azurermagw Provider"
subcategory: ""
description: |-
  
---

# azurermagw Provider
This provider manages the binding service for a backend application to an Azure Application Gateway.
Each backend application can be bound to an existing azure application gateway through a resource called `azurermagw_binding_service`. 
The followings are the main 2 advantages of our azurermagw provider compared to azurerm:
* Currently, the azurerm provider offer this service but for all backend applications at the same time and through the same resource (`azurerm_application_gateway`), so the same terraform project. We believe that managing such service separately for each standalone application project is a better way. So the binding service could be seen as a separate resource that can created, updated and removed from an existing application gateway without manipulating such huge resource. It’s the same idea as the azurerm resources `azurerm_key_vault_secret`, `azurerm_key_vault_certificate`, `azurerm_key_vault_key` or even `azurerm_key_vault_access_policy` that could be considered as key vault sub-resources that can be handled separately.
* From another side, when using the current azurerm provider (version 3.x) for an application gateway resource, a very simple change in the terraform configuration of the app gateway project (or in the portal) makes the terraform plan or apply very hard to read. Several persons observed the same experience and waited for a coming soon azurerm provider that never come. 

To overcome the readability problem of modified terraform configurations, the go terraform framework type MapNestedAttributes was used to declare several http listeners and request routing rules instead of ListNestedAttributes or SetNestedAttributes. These last types, after experiencing them, were responsible of the readability problem. That’s why we use a map with keys to declare listeners and rules. See the binding service example usage for more details

~> **NOTE:** A different key name has to be set for each listener or rule. It’s of your responsibility the check that the listener or rule keys are all different. 

~> **NOTE:** Once applied, the key name change is not supported. 

-> **Note:** The current provider version support only one instance of the following attributes: backend pool, backend http settings, probe, redirect configuration and ssl certificate. This could be enhanced in future release if required.

-> **Note:** The current provider version support the ssl certificate to be stored in a key vault. This could be enhanced in future release if required.


# Authentication
The provider interact with azure cloud through API calls. Indeed, an authentication needs to be done to allow this interaction.
Two authentication methods are supported till now.


## Serivice principal
You can use the credentials of an existing service principal. You can configure these credentials in two different ways:

### Environment Variables
Put these environment variables with the corresponding values.

```shell
$ export AZURE_CLIENT_ID="00000000-0000-0000-0000-000000000000"
$ export AZURE_CLIENT_SECRET="00000000-0000-0000-0000-000000000000"
$ export AZURE_SUBSCRIPTION_ID="00000000-0000-0000-0000-000000000000"
$ export AZURE_TENANT_ID="00000000-0000-0000-0000-000000000000"
```
Then put the following in the terraform file:

```hcl
terraform {
  required_providers {
    azurermagw = {
      source = "Citeo/azurermagw"
      version = "0.3.0"
    }
  }
}
provider "azurermagw" {
}
```

### Provider attributes
Or put the following in the terraform file (replace the corresponding values):

```hcl
terraform {
  required_providers {
    azurermagw = {
      source = "Citeo/azurermagw"
      version = "0.3.0"
    }
  }
}

provider "azurermagw" {
  subscription_id = "00000000-0000-0000-0000-000000000000"
  client_id       = "00000000-0000-0000-0000-000000000000"
  client_secret   = "00000000-0000-0000-0000-000000000000"
  tenant_id       = "00000000-0000-0000-0000-000000000000"
}
```
## az login
Before using the provider, you have to make manually the login to azure, ex. by using 
```shell
az login
```
Then the provider can extract an access token that will be used to interact with azure API.

<!-- schema generated by tfplugindocs -->
## Schema

### Optional

- `azure_client_id` (String) The Client ID which should be used (only Service principal is supported actually).
- `azure_client_secret` (String, Sensitive) The Client Secret which should be used.
- `azure_subscription_id` (String) The Subscription ID which should be used.
- `azure_tenant_id` (String) The Tenant ID which should be used.
